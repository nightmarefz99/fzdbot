# TODO: "start_event" -> insert new event id into the 'events_scheduled' table
#    move "check_for_active_event" and "get_user_id" calls to fzd_db.py functions
#    no need to call them in the async commands below, let the db functions handle it internally
# Function for editScore and deleteScore to check valid opton and return string if not valid
import os
import datetime
from dotenv import load_dotenv
import discord
from discord.ext import commands
from discord import app_commands
from responses import get_response
import mysql.connector
from fzd_db import connect_to_database
from fzd_db import db_get_users
from fzd_db import get_user_id
from fzd_db import get_user_scores
from fzd_db import submit_score
from fzd_db import edit_score
from fzd_db import check_for_active_event
from fzd_db import add_new_user
from fzd_db import modify_user_display_name




# LOAD INFO FROM .env FILE
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD_ID = discord.Object(id=os.getenv('SERVER_ID'))

# BOT SETUP
intents = discord.Intents.default()
intents.message_content = True  # Required to read message content

# Initialize global variable that holds value of current FZD event being run
# (default is NULL when no event is ongoing)
current_event = {'name':"NULL", 'id':0}


# MESSAGING FUNCTIONALITY
async def send_message(message: discord.Message, user_message: str) -> None:
    if not user_message:
        print('(Message empty, intents were not enabled most likely)')
        return
    try:
        response = get_response(user_message)
        await message.channel.send(response) 
    except Exception as e:
        print(e)

class Client(commands.Bot):
    async def on_ready(self) -> None:
        print(f'{self.user} is now running!')
        try:
            # Force sync so bot command changes will appear right away
            synced = await self.tree.sync(guild=GUILD_ID)
            print(f'Synced {len(synced)} commands to guild {GUILD_ID.id}')
        except Exception as e:
            print(f'Wrror syncing commands: {e}')

    #async def on_message(self, message: discord.Message) -> None:
    #    if message.author == self.user:
    #        return
    #    username     = str(message.author)
    #    user_message = message.content
    #    channel      = str(message.channel)
    #
    #    print(f'[{channel}] {username}: "{user_message}"')
    #    await send_message(message, user_message)

# Define the confirmation view
class ConfirmView(discord.ui.View):
    def __init__(self, original_interaction):
        super().__init__(timeout=60) # Set a timeout for the view
        self.original_interaction = original_interaction
        self.confirmed = False

    @discord.ui.button(label="Yes", style=discord.ButtonStyle.green)
    async def confirm_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.confirmed = True
        self.stop() # Stop listening for further interactions
        await interaction.response.edit_message(content="Action confirmed!", view=None) # Remove buttons
        # Execute the action here
        await self.original_interaction.followup.send("Score successfully deleted!")

    @discord.ui.button(label="No", style=discord.ButtonStyle.red)
    async def cancel_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.confirmed = False
        self.stop() # Stop listening for further interactions
        await interaction.response.edit_message(content="Action canceled.", view=None) # Remove buttons

    async def on_timeout(self):
        # Handle timeout if no button is pressed
        if not self.confirmed:
            await self.original_interaction.edit_original_response(content="Confirmation timed out.", view=None)


#class Menu(discord.ui.Select):
#    def __init__(self):
#        options = [
#            discord.SelectOption(
#                label="982",
#                description="",
#                #emoji=""
#            ),
#            discord.SelectOption(
#                label="865",
#                description="",
#                #emoji=""
#            ),
#        ]
#        
#        super().__init__(placeholder="Choose a score to modify:", min_values=1, max_values=1, options=options)
#
#    async def callback(self, interaction: discord.Interaction):
#        label=f"Score being modified: {self.values[0]}"
#        await interaction.response.send_modal(TextboxModal(label=label))
#           
#class MenuView(discord.ui.View):
#    def __init__(self):
#        super().__init__()
#        self.add_item(Menu())


def main() -> None:
    # Define bot client according to Client class above
    client = Client(command_prefix="!",intents=intents)

    # Establish database connection and get all users in database
    db_connect = connect_to_database()
    #allusers = db_get_users(db_connect)

    #db_user_id = [d['id'] for d in allusers if d['discord_user_id'] == "nickg0949"]
    #print(db_user_id)
    #for i in allusers:
        #print(f"{i['discord_user_id']}, {i['discord_display_name']}, {'nickg0949'==i['discord_user_id']}")
    #exit()

    #list_of_usernames = [u["discord_display_name"] for u in users]
    #print(list_of_usernames)

    #This is how to create slash command
    #@client.tree.command(name="helloworld", description="Say 'Hello World'", guild=GUILD_ID)
    #async def sayHello(interaction: discord.Interaction):
    #    await interaction.response.send_message("Hello World")
    
    # Start an event from dropdown list
    @client.tree.command(name="start_event", description="Choose FZD event to start", guild=GUILD_ID)
    @app_commands.choices(event=[ 
        app_commands.Choice(name="Machine Mastery Monday", value="8"),
        app_commands.Choice(name="Wacky Wednesday", value="-999"),
        app_commands.Choice(name="Thursday FZD", value="9"),
        app_commands.Choice(name="Friday FZD", value="10"),
        app_commands.Choice(name="Euro-Asia Drift", value="13"),
        app_commands.Choice(name="Cracked Cup", value="11"),
        app_commands.Choice(name="Asia-Pacific Cup", value="12"),
        app_commands.Choice(name="Weekly Classic Mini", value="7"),
        app_commands.Choice(name="Classic Machine Mastery", value="14"),
        app_commands.Choice(name="Special Event", value="99")
    ])
    async def startEvent(interaction: discord.Interaction, event: app_commands.Choice[str]):
        now = datetime.datetime.now()
        nowdate = now.strftime("%Y-%m-%d %H:%M:%S")
        
        global current_event
        if (current_event['name'] != "NULL"):
            await interaction.response.send_message(f"ERROR! Another event is currently running! Did you forget to end it?")
            print(f"USER ERROR: User {interaction.user} tried to start {event.name} at {nowdate},"
                   "but there is another event currently running: {current_event['name']}")
        else:
            await interaction.response.send_message(f"FZD event {event.name} successfully started!")
            current_event['name'] = event.name
            current_event['id'] = int(event.value)
            print(f'User {interaction.user} just started the event {event.name} at {nowdate}')
 
    # End an event
    @client.tree.command(name="end_event", description="End an ongoing FZD event", guild=GUILD_ID)
    async def endEvent(interaction: discord.Interaction):
        view = ConfirmView(interaction) 
        global current_event
        await interaction.response.send_message(f"Are you sure you want to end the event '{current_event['name']}'?", 
                        view=view,  ephemeral=True) # Ephemeral for private confirmation
        await view.wait() # Wait for user to make choice
        print(f"End Event value: {view.confirmed}")	
        if view.confirmed:
            current_event = {'name':"NULL", 'id':0}

    # This command stores one argument given by user
    @client.tree.command(name="add_score", description="Add score to FZD scoreboard database", guild=GUILD_ID)
    async def addScore(interaction: discord.Interaction, score: int):
        global current_event
        if score < 0:
            await interaction.response.send_message(f"Please enter a positive integer! ")
        else:
            db_user_id = get_user_id(db_connect, interaction.user.name)
            if db_user_id is None:
                add_new_user(db_connect, interaction.user, display_name=interaction.user.nick[0:10])
            current_event = check_for_active_event(db_connect)
            if (current_event['name'] != "NULL"):
                print(f"current event active: {current_event}")
                print(f"{interaction.user}, with id {db_user_id}, entered data")
                user_data = [current_event['id'], db_user_id, score] 
                submit_score(db_connect, user_data)
                await interaction.response.send_message(f"User {interaction.user} has entered a score of {score} to {current_event['name']}")
            else: 
                await interaction.response.send_message(f"ERROR! No event is active, score was not added!  ")

    # This command registers a user into the database
    @client.tree.command(name="register", description="Register your discord id to FZD scoreboard database", guild=GUILD_ID)
    async def registerUser(interaction: discord.Interaction, display_name: str = None):
        if display_name is None:
            display_name = interaction.user.nick[0:10]
        elif len(display_name) > 10:
            display_name = display_name[0:10]
            await interaction.response.send_message(f"Warning: display_name should be 10 characters or less (as in F-Zero 99 in game name)")
        
        db_user_id = get_user_id(db_connect,interaction.user.name)
        if db_user_id is None:
            add_new_user(db_connect, interaction.user, display_name=display_name)
            await interaction.response.send_message(f"User {interaction.user} is now registered in the FZD database with display name {display_name}!!!")
        else:
            modify_user_display_name(db_connect, db_user_id, display_name)
            await interaction.response.send_message(f"User {interaction.user} successfully modified their display name to {display_name}!")
    
    # For edit_score command
    class TextboxModal(discord.ui.Modal, title="Modify Prior Submitted Score"):
        def __init__(self, label: str):
            myinput = discord.ui.TextInput(
                         placeholder="Type modified score (integer only!)...",
                         style=discord.TextStyle.short,
                         label=label
                      )
            super().__init__(title=self.title)
            self.add_item(myinput)

        async def on_submit(self, interaction: discord.Interaction):
            try:
               newscore = int(self.children[0].value)
               current_event = check_for_active_event(db_connect)
               db_user_id = get_user_id(db_connect, interaction.user.name)
               edit_score(db_connect, (newscore, current_event['id'], db_user_id, self.oldscore))
               await interaction.response.send_message(f"✅ User {interaction.user.name} has modified submitted score from {self.oldscore} to {newscore}") #(view=MenuView(), ephemeral=True) 
            except ValueError:
               await interaction.response.send_message(f"❌  ERROR! Please enter an integer value!", ephemeral=True) #(view=MenuView(), ephemeral=True)
            self.stop() 

    # This command queries the database for scores of a current event to edit for a user
    @client.tree.command(name="edit_score", description="Edit a submitted score to FZD scoreboard database", guild=GUILD_ID)
    async def editScore(interaction: discord.Interaction, score: str, new_score: str):
        valid_options = get_user_scores(db_connect, interaction.user.name)
        if score not in valid_options:
            await interaction.response.send_message(f"❌ '{score}' is not a valid choice for you. Please select one of the options shown: {valid_options}", ephemeral=True) 
        elif score == "NO CURRENT EVENT":
            await interaction.response.send_message(f"❌  No current event active, can't edit scores! If you need help, contact an FZD mod", ephemeral=True)
        elif score == "NO USER SCORES FOUND":
            await interaction.response.send_message(f"❌  No submitted scores found for user {interaction.user.name}! If you need help, contact an FZD mod", ephemeral=True) #(view=MenuView(), ephemeral=True)
        else:
            try:
               current_event = check_for_active_event(db_connect)
               db_user_id = get_user_id(db_connect, interaction.user.name)
               edit_score(db_connect, (int(new_score), current_event['id'], db_user_id, score))
               await interaction.response.send_message(f"✅ User {interaction.user.name} has modified submitted score from {score} to {new_score}") #(view=MenuView(), ephemeral=True) 
            except ValueError:
               await interaction.response.send_message(f"❌  ERROR! Please enter an integer value!", ephemeral=True) #(view=MenuView(), ephemeral=True)
            #label=f"Score being modified: {score}"
            #modal=TextboxModal(label=label)
            #modal.oldscore = score # Send old score to TextboxModal class for interaction response
            #await interaction.response.send_modal(modal)

    # This command queries the database for scores of a current event to delete for a user
    @client.tree.command(name="delete_score", description="Edit a submitted score to FZD scoreboard database", guild=GUILD_ID)
    async def deleteScore(interaction: discord.Interaction, score: str):
        valid_options = get_user_scores(db_connect, interaction.user.name)
        if score not in valid_options:
            await interaction.response.send_message(f"❌ '{score}' is not a valid choice for you. Please select one of the options shown: {valid_options}", ephemeral=True)
        elif score == "NO CURRENT EVENT":
            await interaction.response.send_message(f"❌  No current event active, can't edit scores! If you need help, contact an FZD mod", ephemeral=True)
        elif score == "NO USER SCORES FOUND":
            await interaction.response.send_message(f"❌  No submitted scores found for user {interaction.user.name}! If you need help, contact an FZD mod", ephemeral=True) #(view=MenuView(), ephemeral=True)
        else:
            current_event = check_for_active_event(db_connect)
            db_user_id = get_user_id(db_connect, interaction.user.name)
            edit_score(db_connect, (current_event['id'], db_user_id, score), delete=True)
            await interaction.response.send_message(f"✅ User {interaction.user.name} has successfully deleted score = {score} entry from database")

    # Autocomplete handler for editScore and deleteScore
    @editScore.autocomplete("score")
    @deleteScore.autocomplete("score")
    async def option_autocomplete(interaction: discord.Interaction, current: str):
        user_scores = get_user_scores(db_connect, interaction.user.name)
         
        print(user_scores)
        print(type(user_scores))
        # Filter based on what the user is currently typing
        choices = [opt for opt in user_scores if current.lower() in opt.lower()]

        # Return up to 25 results (discord limit)
        return [app_commands.Choice(name=opt, value=opt) for opt in choices[:25]]
  
 
    # creats scoreboard embed
    @client.tree.command(name="show", description="Show most current FZD event scoreboard", guild=GUILD_ID)
    async def showScoreboard(interaction: discord.Interaction):
        scoreboard = discord.Embed(title="FZD Scoreboard", description="This is the FZD scoreboard")
        scoreboard.set_thumbnail(url="https://media.discordapp.net/attachments/1399501477608951933/1400792457007861800/Supernova_Server_Icon.png?ex=689c6da3&is=689b1c23&hm=68b8d8790d30689fbad0dfb9341c78921ecf9afecc5919880c81680329c32644&=&format=webp&quality=lossless&width=1024&height=1024")
        scoreboard.add_field(name="", value="Hi", inline=False) #inline tells it whether another field can share same line
        #scoreboard.set_footer(text="This is teh footer")
        await interaction.response.send_message(embed=scoreboard)   

    #print(f"current event = {current_event}") 
    
    client.run(token=TOKEN)

if __name__ == '__main__':
    main()
